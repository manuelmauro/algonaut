/*
 * Indexer
 *
 * Algorand ledger analytics API.
 *
 * The version of the OpenAPI document: 2.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`lookup_account_app_local_states`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountAppLocalStatesError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_account_assets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountAssetsError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_account_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountByIdError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_account_created_applications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountCreatedApplicationsError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_account_created_assets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountCreatedAssetsError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_account_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountTransactionsError {
    Status400(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_application_box_by_id_and_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupApplicationBoxByIdAndNameError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_application_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupApplicationByIdError {
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_application_logs_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupApplicationLogsByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_asset_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAssetBalancesError {
    Status400(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_asset_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAssetByIdError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_asset_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAssetTransactionsError {
    Status400(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupBlockError {
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupTransactionError {
    Status400(crate::models::SearchForAccounts400Response),
    Status404(crate::models::SearchForAccounts400Response),
    Status500(crate::models::SearchForAccounts400Response),
    UnknownValue(serde_json::Value),
}

/// Lookup an account's asset holdings, optionally for a specific ID.
pub async fn lookup_account_app_local_states(
    configuration: &configuration::Configuration,
    account_id: &str,
    application_id: Option<i32>,
    include_all: Option<bool>,
    limit: Option<i32>,
    next: Option<&str>,
) -> Result<
    crate::models::LookupAccountAppLocalStates200Response,
    Error<LookupAccountAppLocalStatesError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}/apps-local-state",
        local_var_configuration.base_path,
        account_id = crate::apis::urlencode(account_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = application_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("application-id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountAppLocalStatesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup an account's asset holdings, optionally for a specific ID.
pub async fn lookup_account_assets(
    configuration: &configuration::Configuration,
    account_id: &str,
    asset_id: Option<i32>,
    include_all: Option<bool>,
    limit: Option<i32>,
    next: Option<&str>,
) -> Result<crate::models::LookupAccountAssets200Response, Error<LookupAccountAssetsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}/assets",
        local_var_configuration.base_path,
        account_id = crate::apis::urlencode(account_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = asset_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("asset-id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountAssetsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup account information.
pub async fn lookup_account_by_id(
    configuration: &configuration::Configuration,
    account_id: &str,
    round: Option<i32>,
    include_all: Option<bool>,
    exclude: Option<Vec<String>>,
) -> Result<crate::models::LookupAccountById200Response, Error<LookupAccountByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}",
        local_var_configuration.base_path,
        account_id = crate::apis::urlencode(account_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = round {
        local_var_req_builder =
            local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("exclude".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "exclude",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup an account's created application parameters, optionally for a specific ID.
pub async fn lookup_account_created_applications(
    configuration: &configuration::Configuration,
    account_id: &str,
    application_id: Option<i32>,
    include_all: Option<bool>,
    limit: Option<i32>,
    next: Option<&str>,
) -> Result<
    crate::models::LookupAccountCreatedApplications200Response,
    Error<LookupAccountCreatedApplicationsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}/created-applications",
        local_var_configuration.base_path,
        account_id = crate::apis::urlencode(account_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = application_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("application-id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountCreatedApplicationsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup an account's created asset parameters, optionally for a specific ID.
pub async fn lookup_account_created_assets(
    configuration: &configuration::Configuration,
    account_id: &str,
    asset_id: Option<i32>,
    include_all: Option<bool>,
    limit: Option<i32>,
    next: Option<&str>,
) -> Result<
    crate::models::LookupAccountCreatedAssets200Response,
    Error<LookupAccountCreatedAssetsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}/created-assets",
        local_var_configuration.base_path,
        account_id = crate::apis::urlencode(account_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = asset_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("asset-id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountCreatedAssetsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup account transactions. Transactions are returned newest to oldest.
pub async fn lookup_account_transactions(
    configuration: &configuration::Configuration,
    account_id: &str,
    limit: Option<i32>,
    next: Option<&str>,
    note_prefix: Option<&str>,
    tx_type: Option<&str>,
    sig_type: Option<&str>,
    txid: Option<&str>,
    round: Option<i32>,
    min_round: Option<i32>,
    max_round: Option<i32>,
    asset_id: Option<i32>,
    before_time: Option<String>,
    after_time: Option<String>,
    currency_greater_than: Option<i32>,
    currency_less_than: Option<i32>,
    rekey_to: Option<bool>,
) -> Result<
    crate::models::LookupAccountTransactions200Response,
    Error<LookupAccountTransactionsError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/accounts/{account_id}/transactions",
        local_var_configuration.base_path,
        account_id = crate::apis::urlencode(account_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = note_prefix {
        local_var_req_builder =
            local_var_req_builder.query(&[("note-prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tx_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("tx-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sig_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("sig-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = txid {
        local_var_req_builder =
            local_var_req_builder.query(&[("txid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = round {
        local_var_req_builder =
            local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_round {
        local_var_req_builder =
            local_var_req_builder.query(&[("min-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_round {
        local_var_req_builder =
            local_var_req_builder.query(&[("max-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = asset_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("asset-id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before_time {
        local_var_req_builder =
            local_var_req_builder.query(&[("before-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after_time {
        local_var_req_builder =
            local_var_req_builder.query(&[("after-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_greater_than {
        local_var_req_builder =
            local_var_req_builder.query(&[("currency-greater-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_less_than {
        local_var_req_builder =
            local_var_req_builder.query(&[("currency-less-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rekey_to {
        local_var_req_builder =
            local_var_req_builder.query(&[("rekey-to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountTransactionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Given an application ID and box name, returns base64 encoded box name and value. Box names must be in the goal app call arg form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, encode base 64 and use 'b64' prefix as in 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
pub async fn lookup_application_box_by_id_and_name(
    configuration: &configuration::Configuration,
    application_id: i32,
    name: &str,
) -> Result<crate::models::Box, Error<LookupApplicationBoxByIdAndNameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/applications/{application_id}/box",
        local_var_configuration.base_path,
        application_id = application_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("name", &name.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupApplicationBoxByIdAndNameError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup application.
pub async fn lookup_application_by_id(
    configuration: &configuration::Configuration,
    application_id: i32,
    include_all: Option<bool>,
) -> Result<crate::models::LookupApplicationById200Response, Error<LookupApplicationByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/applications/{application_id}",
        local_var_configuration.base_path,
        application_id = application_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupApplicationByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup application logs.
pub async fn lookup_application_logs_by_id(
    configuration: &configuration::Configuration,
    application_id: i32,
    limit: Option<i32>,
    next: Option<&str>,
    txid: Option<&str>,
    min_round: Option<i32>,
    max_round: Option<i32>,
    sender_address: Option<&str>,
) -> Result<
    crate::models::LookupApplicationLogsById200Response,
    Error<LookupApplicationLogsByIdError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/applications/{application_id}/logs",
        local_var_configuration.base_path,
        application_id = application_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = txid {
        local_var_req_builder =
            local_var_req_builder.query(&[("txid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_round {
        local_var_req_builder =
            local_var_req_builder.query(&[("min-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_round {
        local_var_req_builder =
            local_var_req_builder.query(&[("max-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sender_address {
        local_var_req_builder =
            local_var_req_builder.query(&[("sender-address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupApplicationLogsByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup the list of accounts who hold this asset
pub async fn lookup_asset_balances(
    configuration: &configuration::Configuration,
    asset_id: i32,
    include_all: Option<bool>,
    limit: Option<i32>,
    next: Option<&str>,
    currency_greater_than: Option<i32>,
    currency_less_than: Option<i32>,
) -> Result<crate::models::LookupAssetBalances200Response, Error<LookupAssetBalancesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/assets/{asset_id}/balances",
        local_var_configuration.base_path,
        asset_id = asset_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_greater_than {
        local_var_req_builder =
            local_var_req_builder.query(&[("currency-greater-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_less_than {
        local_var_req_builder =
            local_var_req_builder.query(&[("currency-less-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAssetBalancesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup asset information.
pub async fn lookup_asset_by_id(
    configuration: &configuration::Configuration,
    asset_id: i32,
    include_all: Option<bool>,
) -> Result<crate::models::LookupAssetById200Response, Error<LookupAssetByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/assets/{asset_id}",
        local_var_configuration.base_path,
        asset_id = asset_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_all {
        local_var_req_builder =
            local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAssetByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup transactions for an asset. Transactions are returned oldest to newest.
pub async fn lookup_asset_transactions(
    configuration: &configuration::Configuration,
    asset_id: i32,
    limit: Option<i32>,
    next: Option<&str>,
    note_prefix: Option<&str>,
    tx_type: Option<&str>,
    sig_type: Option<&str>,
    txid: Option<&str>,
    round: Option<i32>,
    min_round: Option<i32>,
    max_round: Option<i32>,
    before_time: Option<String>,
    after_time: Option<String>,
    currency_greater_than: Option<i32>,
    currency_less_than: Option<i32>,
    address: Option<&str>,
    address_role: Option<&str>,
    exclude_close_to: Option<bool>,
    rekey_to: Option<bool>,
) -> Result<crate::models::LookupAccountTransactions200Response, Error<LookupAssetTransactionsError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/assets/{asset_id}/transactions",
        local_var_configuration.base_path,
        asset_id = asset_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder =
            local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = note_prefix {
        local_var_req_builder =
            local_var_req_builder.query(&[("note-prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tx_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("tx-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sig_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("sig-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = txid {
        local_var_req_builder =
            local_var_req_builder.query(&[("txid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = round {
        local_var_req_builder =
            local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_round {
        local_var_req_builder =
            local_var_req_builder.query(&[("min-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_round {
        local_var_req_builder =
            local_var_req_builder.query(&[("max-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before_time {
        local_var_req_builder =
            local_var_req_builder.query(&[("before-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after_time {
        local_var_req_builder =
            local_var_req_builder.query(&[("after-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_greater_than {
        local_var_req_builder =
            local_var_req_builder.query(&[("currency-greater-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_less_than {
        local_var_req_builder =
            local_var_req_builder.query(&[("currency-less-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address {
        local_var_req_builder =
            local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address_role {
        local_var_req_builder =
            local_var_req_builder.query(&[("address-role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_close_to {
        local_var_req_builder =
            local_var_req_builder.query(&[("exclude-close-to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rekey_to {
        local_var_req_builder =
            local_var_req_builder.query(&[("rekey-to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAssetTransactionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup block.
pub async fn lookup_block(
    configuration: &configuration::Configuration,
    round_number: i32,
    header_only: Option<bool>,
) -> Result<crate::models::Block, Error<LookupBlockError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/blocks/{round_number}",
        local_var_configuration.base_path,
        round_number = round_number
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = header_only {
        local_var_req_builder =
            local_var_req_builder.query(&[("header-only", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupBlockError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup a single transaction.
pub async fn lookup_transaction(
    configuration: &configuration::Configuration,
    txid: &str,
) -> Result<crate::models::LookupTransaction200Response, Error<LookupTransactionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/transactions/{txid}",
        local_var_configuration.base_path,
        txid = crate::apis::urlencode(txid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupTransactionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
